import { js2xml, xml2js } from 'xml-js';
import fetch from 'node-fetch';
import getMessageContainer from './util/get-message-container';
import getResponse from './util/get-response';
import Payor from './schemas/payor';
import Token from './schemas/token';
import Payment from './schemas/payment';

const toXml = x => js2xml(x, { spaces: 4, compact: true });
const fromXml = x => xml2js(x, { compact: true });

const request = async (url, payload) => {
  const xml = toXml(payload);
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'text/xml' },
    body: xml
  }).then(x => x.text());
  return getResponse(fromXml(response));
};

const clean = el => {
  return response => {
    const result = response.SecurePayMessage;
    result.Data = result[el][el + 'List'][el + 'Item'];
    delete result[el];
    return result;
  };
};

export default class SecurePay {
  /**
   * @summary SecurePay API wrapper
   * @class
   * @param {Object} config
   * @param {String} config.merchantId 5 or 7-character merchant ID supplied by SecurePay.
   * @param {String} config.password Transaction password. Password used for authentication of the merchant’s request message, supplied by SecurePay.
   * @param {Object} [options]
   * @param {Boolean} options.testMode Set to `true` to direct requests to the SecurePay test environment.
   * @param {String} options.timeout Timeout value used, in seconds.
   */
  constructor(config, options = {}) {
    this.merchantId = config.merchantId;
    this.password = config.password;
    this.baseUrl = options.testMode
      ? 'https://test.api.securepay.com.au/xmlapi/'
      : 'https://api.securepay.com.au/xmlapi/';
  }

  _getCredentials() {
    return {
      merchantId: this.merchantId,
      password: this.password
    };
  }

  _post(type, payload) {
    const el = type.charAt(0).toUpperCase() + type.slice(1);
    return request(this.baseUrl + type, payload).then(clean(el));
  }

  /**
   * @summary Add a new payor to the payor list
   * @param {String} messageId Unique identifier for the XML message. Generated by the merchant.
   * The `messageId` is a reference for the xml request. If you had a server internally you could store all your xml request and this would be a way to locate the request if a payment was to fail.
   * A request will still be sent if they have the same `messageId` and will be treated as a new xml request.
   * @param {Object} payorDetails
   * @param {String} payorDetails.clientID Unique identifier. Eg, customer reference number.
   * @param {String} payorDetails.currency Default currency to be stored with Token. The amount can be overridden be passing an amount when triggering a payment.
   * @param {String} payorDetails.amount Default amount in cents to be stored with Token. The amount can be overridden be passing an amount when triggering a payment.
   * @param {Object} payorDetails.CreditCardInfo
   * @param {String} payorDetails.CreditCardInfo.cardNumber Credit card number.
   * @param {String} payorDetails.CreditCardInfo.expiryDate MM/YY Credit card expiry date.
   * @param {String} payorDetails.CreditCardInfo.cardHolderName Credit cardholder name.
   * @returns {Promise}
   */
  addPayor(messageId, payorDetails) {
    const payload = getMessageContainer({
      messageId,
      credentials: this._getCredentials(),
      requestType: 'Periodic',
      dataElementName: 'Periodic',
      payload: {
        actionType: 'add',
        periodicType: '4',
        ...new Payor(payorDetails).toObject()
      }
    });
    return this._post('periodic', payload);
  }

  /**
   * @summary Add a new token to the payor list
   * @param {String} messageId The `messageId` is a reference for the xml request. If you had a server internally you could store all your xml request and this would be a way to locate the request if a payment was to fail. A request will still be sent if they have the same `messageId` and will be treated as a new xml request.
   * @param {Object} tokenDetails
   * @param {Object} tokenDetails.cardNumber Credit card number.
   * @param {String} tokenDetails.expiryDate Credit card expiry date.
   * @param {String} tokenDetails.currency Default currency to be stored with Token. The amount can be overridden be passing an amount when triggering a payment.
   * @param {String} tokenDetails.amount Default amount in cents to be stored with Token. The amount can be overridden be passing an amount when triggering a payment.
   * @param {String} tokenDetails.transactionReference The transaction identifier. This value will appear against all processed transactions. Typically an invoice number. E.g. "invoice12345". If absent the Token value will be used.
   * @returns {Promise}
   * const result = {
      "MessageInfo": {
        "messageID": "123456789",
        "messageTimestamp": "2017-10-20T00:00:00.000Z",
        "apiVersion": "xml-4.2"
      },
      "RequestType": "Payment",
      "MerchantInfo": {
        "merchantID": "ABC0001"
      },
      "Status": {
        "statusCode": "0",
        "statusDescription": "Normal"
      },
      "Data": {
        "_attributes": {
          "ID": "1"
        },
        "responseCode": "00",
        "responseText": "Successful",
        "successful": "yes",
        "tokenValue": "8714448311797575",
        "CreditCardInfo": {
          "pan": "453934XXXXXXX716",
          "expiryDate": "08/23",
          "cardType": "6",
          "cardDescription": "Visa"
        },
        "amount": "100",
        "transactionReference": "test transaction - node-securepay"
      }
   */
  addToken(messageId, tokenDetails) {
    const payload = getMessageContainer({
      messageId,
      credentials: this._getCredentials(),
      requestType: 'addToken',
      dataElementName: 'Token',
      payload: {
        tokenType: 1, // The type of token created. Defaults to 1 if absent. Type 1 is 16 digits, not based on the card number, failing the LUHN check.
        ...new Token(tokenDetails).toObject()
      }
    });
    return this._post('token', payload);
  }

  /**
   * @param {String} messageId The `messageId` is a reference for the xml request. If you had a server internally you could store all your xml request and this would be a way to locate the request if a payment was to fail. A request will still be sent if they have the same `messageId` and will be treated as a new xml request.
   * @param {String} tokenValue The token value that represents a stored card within SecurePay
   * @returns {Promise}
   * const result = {
      MessageInfo: {
        messageID: '123456789',
        messageTimestamp: '2017-10-20T00:00:00.000Z',
        apiVersion: 'xml-4.2'
      },
      RequestType: 'Payment',
      MerchantInfo: { merchantID: 'ABC0001' },
      Status: { statusCode: '0', statusDescription: 'Normal' },
      Data: {
        _attributes: { ID: '1' },
        responseCode: '00',
        responseText: 'Successful',
        successful: 'yes',
        tokenValue: '8714448311797575',
        CreditCardInfo: {
          pan: '453934XXXXXXX716',
          expiryDate: '08/23',
          cardType: '6',
          cardDescription: 'Visa'
        },
        amount: '100',
        transactionReference: 'test transaction - node-securepay'
      }
    };
   */
  lookupToken(messageId, tokenValue) {
    const payload = getMessageContainer({
      messageId,
      credentials: this._getCredentials(),
      requestType: 'lookupToken',
      dataElementName: 'Token',
      payload: { tokenValue }
    });
    return this._post('token', payload);
  }

  /**
   * @param {String} messageId The `messageId` is a reference for the xml request. If you had a server internally you could store all your xml request and this would be a way to locate the request if a payment was to fail. A request will still be sent if they have the same `messageId` and will be treated as a new xml request.
   * @param {String} tokenValue The token value that represents a stored card within SecurePay
   * @returns {Promise}
   * const result = {
      MessageInfo: {
        messageID: '123456789',
        messageTimestamp: '20172211194828703000+660',
        apiVersion: 'spxml-4.2'
      },
      RequestType: 'Periodic',
      MerchantInfo: { merchantID: 'ABC0001' },
      Status: { statusCode: '0', statusDescription: 'Normal' },
      Data: {
        _attributes: { ID: '1' },
        actionType: 'delete',
        clientID: '5115275733251415',
        responseCode: '00',
        responseText: 'Successful',
        successful: 'yes'
      }
    };
   */
  deleteToken(messageId, tokenValue) {
    const payload = getMessageContainer({
      messageId,
      credentials: this._getCredentials(),
      requestType: 'Periodic',
      dataElementName: 'Periodic',
      payload: {
        actionType: 'delete',
        clientID: tokenValue
      }
    });
    return this._post('periodic', payload);
  }

  /**
   * @param {String} messageId The `messageId` is a reference for the xml request. If you had a server internally you could store all your xml request and this would be a way to locate the request if a payment was to fail. A request will still be sent if they have the same `messageId` and will be treated as a new xml request.
   * @param {Object} paymentDetails {timeout, testMode}
   * @param {String} paymentDetails.clientID Unique identifier of payor or token.
   * @param {String} paymentDetails.currency Default currency is "AUD" – Australian Dollars.
   * @param {String} paymentDetails.amount Transaction amount in cents.
   * @param {String} paymentDetails.tokenDetails.transactionReference The transaction identifier. This value will appear against all processed transactions. Typically an invoice number. E.g. "invoice12345". If absent the Token value will be used.
   * @returns {Promise}
   */
  triggerPayment(messageId, paymentDetails) {
    const payload = getMessageContainer({
      messageId,
      credentials: this._getCredentials(),
      requestType: 'Periodic',
      dataElementName: 'Periodic',
      payload: {
        actionType: 'trigger',
        ...new Payment(paymentDetails).toObject()
      }
    });
    return this._post('periodic', payload);
  }
}
